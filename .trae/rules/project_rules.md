## 查看项目的 readme.md 文件

- 更新功能模块后需要更新 readme.md 文件

## coding 时候需要遵循当前项目的架构

## 测试

- 新增的功能模块必须完善单元测试
- 单元测试，集成测试，功能测试文件都放到 src/tests 目录下
- 临时测试文件放到 src/tests/temp 目录下

## 通用礼节

优先保证代码简洁易懂。
别搞过度设计，简单实用就好。

## 写代码时，要注意圈复杂度，函数尽量小，尽量可以复用，尽量不写重复代码。

## 实验性规则：

当你被要求修复一个 Bug 时，请遵循以下步骤：
理解问题：仔细阅读 Bug 描述和相关代码，复述你对问题的理解。
分析原因：提出至少两种可能的根本原因。
让客户选择修复的方案。
代码规范
缩进使用 4 个空格，不使用制表符。
变量和函数命名采用驼峰式命名法，类名采用大驼峰式命名法。
文档规范
新项目开发启动时，必须优先创建「说明文档.md」，作为项目全生命周期唯一管理载体。
文档需提供中英文两个版本，新属性需声明可用的版本号。

每次的代码修改必须 有单元测试。
新功能开发 必须有单元测试
修复 bug 必须有单元测试。

## 要求代码低耦合 低复杂度

<!-- 6A
Align（对齐）
目标：确保需求理解零偏差。
反偷懒机制：强制要求用结构化模板定义需求，AI 必须输出「需求对齐确认表」，包含需求方预期、AI 理解、差异点及解决方式。
Architect（架构设计）
目标：生成可落地的技术方案。
反偷懒机制：强制使用 Mermaid 语法输出架构图，要求标注分层结构、数据流、新旧系统集成点等，并新增「复杂度评估」环节，AI 需标注方案中高风险模块。
Atomize（原子化拆分）
目标：将任务分解到不可再分的原子单元。
反偷懒机制：每个原子任务必须满足 INVEST 原则，即 Independent（独立的）、Negotiable（可协商的）、Valuable（有价值的）、Estimable（可估算的）、Small（小的）、Testable（可测试的）。AI 需输出「任务依赖图谱」（DAG 有向无环图），避免循环依赖。
Approve（人工审批）
目标：关键节点阻断 AI 错误蔓延。
反偷懒机制：设置三类强制审批点，分别为架构设计方案、原子任务清单、高风险模块详细设计及集成方案。审批时需对比历史相似案例。
Automate（自动化实现）
目标：生成可直接运行的代码。
反偷懒机制：代码生成必须绑定设计文档，模块命名需与架构图完全一致。强制添加防御性编程桩代码，如输入校验，同时自动注入埋点监控。
Assess（质量评估）
目标：闭环验证交付质量。
反偷懒机制：执行三阶验证，包括静态检查（代码规范，如 ESLint/Sonar 规则集）、动态验证（自动化测试覆盖率 > 80%）、业务校验（需求覆盖率矩阵）。AI 需输出质量溯源报告，将缺陷关联到具体原子任务。 -->
