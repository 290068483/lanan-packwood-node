# 客户归档功能设计文档

## 1. 功能概述

客户归档功能用于将已打包完成的数据进行归档处理，主要包含以下操作：

1. 保存客户数据到数据库（打包的包的信息，和包里面的 id 信息，客户的名字，地址等等）
2. 压缩客户文件夹，保存到 D:\backup_data\backup\customer
3. 删除本地输出目录对应归档的客户文件夹

归档后的数据可以通过"归档历史"功能进行查看和恢复（如果需要）。

## 2. 界面设计

### 2.1 主界面菜单

在上面导航菜单中添加"归档历史"选项，与现有的"客户列表"和"路径配置"并列：

```
[客户数据管理]
├── 客户列表
├── 归档历史
└── 路径配置
```

### 2.2 归档操作界面

在客户列表中，对于状态为"已打包"的客户，显示"归档"按钮。点击后弹出确认对话框：

```
确认归档
----------
您确定要归档客户 [客户名称] 吗？

归档后，系统将：
- 保存客户数据到数据库
- 压缩客户文件夹并保存到备份目录
- 删除本地输出目录中的客户文件夹

备注：
[输入框]

[确认归档] [取消]
```

### 2.3 归档历史界面

点击"归档历史"菜单项后，显示归档客户列表：

```
归档历史
----------

[搜索区域]
- 客户名称: [输入框]
- 归档日期: [开始日期] 至 [结束日期]
- 操作员: [下拉选择]
- [搜索按钮]

[数据表格]
| 客户名称 | 归档日期 | 包数量 | 板件总数 | 操作员 | 操作 |
|---------|---------|--------|---------|--------|------|
| 客户A   | 2023-06-01 | 5      | 120     | 张三   | [查看详情] [恢复] |
| 客户B   | 2023-05-28 | 3      | 75      | 李四   | [查看详情] [恢复] |

[分页控件]
```

### 2.4 归档详情界面

点击"查看详情"按钮后，显示该客户完整的归档信息：

```
客户归档详情
----------

[客户基本信息]
- 客户名称: 客户A
- 客户地址: XX市XX区XX路XX号
- 归档日期: 2023-06-01 10:30:00
- 归档操作员: 张三
- 备注: 归档测试

[包信息列表]
| 包号 | 重量 | 体积 | 创建时间 | 板件列表 |
|-----|-----|-----|---------|---------|
| 包1 | 12.5 | 0.8 | 2023-05-30 09:00:00 | [ID001, ID002, ID003] |
| 包2 | 15.2 | 1.2 | 2023-05-30 10:30:00 | [ID004, ID005] |

[操作按钮]
[导出Excel] [导出PDF] [返回列表]
```

### 2.5 恢复归档界面

点击"恢复"按钮后，显示确认对话框：

```
确认恢复归档
----------
您确定要恢复客户 [客户名称] 的归档数据吗？

恢复后，系统将：
- 将备份文件解压到输出目录
- 从数据库恢复客户状态
- 刷新客户列表

[确认恢复] [取消]
```

## 3. 数据库设计

### 3.1 客户归档表

```sql
CREATE TABLE customer_archive (
    id INT PRIMARY KEY AUTO_INCREMENT,
    customer_name VARCHAR(255) NOT NULL,
    customer_address TEXT,
    archive_date DATETIME NOT NULL,
    backup_path VARCHAR(500) NOT NULL,
    packages_count INT,
    total_parts_count INT,
    archive_user VARCHAR(100),
    remark TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 3.2 包信息表

```sql
CREATE TABLE package_archive (
    id INT PRIMARY KEY AUTO_INCREMENT,
    archive_id INT NOT NULL,
    pack_seq VARCHAR(50) NOT NULL,
    package_weight DECIMAL(10,2),
    package_volume DECIMAL(10,2),
    created_at DATETIME NOT NULL,
    FOREIGN KEY (archive_id) REFERENCES customer_archive(id) ON DELETE CASCADE
);
```

### 3.3 板件 ID 表

```sql
CREATE TABLE part_archive (
    id INT PRIMARY KEY AUTO_INCREMENT,
    package_id INT NOT NULL,
    part_id VARCHAR(100) NOT NULL,
    part_name VARCHAR(255),
    part_quantity INT DEFAULT 1,
    created_at DATETIME NOT NULL,
    FOREIGN KEY (package_id) REFERENCES package_archive(id) ON DELETE CASCADE
);
```

## 4. 功能流程

### 4.1 归档流程

1. 用户在客户列表中点击"归档"按钮
2. 系统显示归档确认对话框
3. 用户输入备注并点击"确认归档"
4. 系统执行归档操作：
   - 保存客户数据到归档数据库表
   - 压缩客户文件夹并保存到 D:\backup_data\backup\customer
   - 删除本地输出目录中的客户文件夹
   - 更新客户状态为"已归档"
5. 系统显示归档成功提示
6. 刷新客户列表，客户状态变为"已归档"

### 4.2 查看归档历史流程

1. 用户点击左侧菜单中的"归档历史"
2. 系统加载归档列表
3. 用户可以通过搜索和筛选功能查找特定归档记录
4. 用户点击"查看详情"查看完整归档信息

### 4.3 恢复归档流程

1. 用户在归档历史列表中点击"恢复"按钮
2. 系统显示确认对话框
3. 用户确认后，系统执行恢复操作：
   - 将备份文件解压到输出目录
   - 从数据库恢复客户状态
   - 更新客户状态为"已打包"
4. 系统显示恢复成功提示
5. 刷新客户列表，客户状态变为"已打包"

## 5. 用户体验设计

### 5.1 加载状态提示

- 归档操作可能需要一定时间，特别是在处理大量数据时
- 在归档过程中显示进度条或加载动画
- 提示用户"正在归档客户数据，请稍候..."
- 避免用户误操作，禁用归档按钮直到操作完成

### 5.2 操作反馈

- 归档成功：显示成功提示，包含归档 ID 和备份路径
- 归档失败：显示错误信息，帮助用户了解失败原因
- 恢复成功：显示成功提示，包含恢复的客户名称
- 恢复失败：显示错误信息，帮助用户了解失败原因

### 5.3 数据可视化

- 在归档历史界面添加归档统计图表
- 显示归档数量随时间的变化趋势
- 按操作员统计归档数量
- 显示归档数据大小统计

### 5.4 错误处理

- 处理磁盘空间不足的情况
- 处理文件权限问题
- 处理数据库连接问题
- 提供清晰的错误提示和解决方案建议

### 5.5 性能优化

- 对于大量归档记录，实现分页加载
- 添加搜索和筛选功能，减少数据加载量
- 对大数据量操作进行优化，避免界面卡顿

## 6. 技术实现

### 6.1 归档管理模块

创建 `utils/customer-archive-manager.js` 文件，实现归档相关功能：

```javascript
const fs = require('fs').promises;
const path = require('path');
const zlib = require('zlib');
const { pipeline } = require('stream');
const { promisify } = require('util');
const config = require('../config.json');
const DataManager = require('./data-manager');
const PackageDataExtractor = require('./package-data-extractor');
const Database = require('../database/database');

const gzip = promisify(zlib.gzip);
const gunzip = promisify(zlib.gunzip);

class CustomerArchiveManager {
  /**
   * 归档客户数据
   * @param {string} customerName - 客户名称
   * @param {string} operator - 操作员
   * @param {string} remark - 备注
   * @returns {Promise} 归档结果
   */
  static async archiveCustomer(customerName, operator = 'system', remark = '') {
    try {
      // 1. 获取客户数据
      const customerData = await DataManager.getCustomer(customerName);
      if (!customerData) {
        throw new Error('客户不存在');
      }

      // 2. 获取包数据
      const packagesPath = path.join(customerData.outputPath, 'packages.json');
      let packagesData = [];
      if (fs.existsSync(packagesPath)) {
        packagesData =
          PackageDataExtractor.extractCustomerPackageData(packagesPath);
      }

      // 3. 创建备份目录
      const backupDir = path.join('D:\backup_data\backupcustomer');
      await fs.mkdir(backupDir, { recursive: true });

      // 4. 压缩客户文件夹
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupFileName = `${customerName}_${timestamp}.zip`;
      const backupPath = path.join(backupDir, backupFileName);

      await this.compressDirectory(customerData.outputPath, backupPath);

      // 5. 保存归档数据到数据库
      const archiveId = await this.saveArchiveToDatabase({
        customerName: customerData.name,
        customerAddress: customerData.address || '',
        backupPath,
        packagesCount: packagesData.length,
        totalPartsCount: this.calculateTotalParts(packagesData),
        archiveUser: operator,
        remark,
        packages: packagesData,
      });

      // 6. 删除本地输出目录
      await fs.rm(customerData.outputPath, { recursive: true, force: true });

      // 7. 更新客户状态为已归档
      await DataManager.updateCustomerStatus(
        customerName,
        '已归档',
        `已归档到 ${backupPath}`,
        operator
      );

      return {
        success: true,
        archiveId,
        message: `客户 ${customerName} 已成功归档`,
      };
    } catch (error) {
      console.error('归档客户失败:', error);
      return {
        success: false,
        message: `归档客户失败: ${error.message}`,
      };
    }
  }

  /**
   * 压缩目录
   * @param {string} sourceDir - 源目录
   * @param {string} outputPath - 输出文件路径
   */
  static async compressDirectory(sourceDir, outputPath) {
    const archiver = require('archiver');
    const output = fs.createWriteStream(outputPath);
    const archive = archiver('zip', { zlib: { level: 9 } });

    return new Promise((resolve, reject) => {
      output.on('close', () => resolve());
      archive.on('error', err => reject(err));

      archive.pipe(output);
      archive.directory(sourceDir, false);
      archive.finalize();
    });
  }

  /**
   * 计算总板件数
   * @param {Array} packages - 包数据
   * @returns {number} 总板件数
   */
  static calculateTotalParts(packages) {
    return packages.reduce((total, pkg) => {
      return total + (pkg.partIDs ? pkg.partIDs.length : 0);
    }, 0);
  }

  /**
   * 保存归档数据到数据库
   * @param {Object} data - 归档数据
   * @returns {Promise<number} 归档ID
   */
  static async saveArchiveToDatabase(data) {
    const db = Database.getInstance();
    const connection = await db.getConnection();

    try {
      await connection.beginTransaction();

      // 插入客户归档记录
      const [archiveResult] = await connection.query(
        `INSERT INTO customer_archive 
        (customer_name, customer_address, archive_date, backup_path, packages_count, total_parts_count, archive_user, remark) 
        VALUES (?, ?, NOW(), ?, ?, ?, ?, ?)`,
        [
          data.customerName,
          data.customerAddress,
          data.backupPath,
          data.packagesCount,
          data.totalPartsCount,
          data.archiveUser,
          data.remark,
        ]
      );

      const archiveId = archiveResult.insertId;

      // 插入包信息
      for (const pkg of data.packages) {
        const [packageResult] = await connection.query(
          `INSERT INTO package_archive 
          (archive_id, pack_seq, package_weight, package_volume, created_at) 
          VALUES (?, ?, ?, ?, NOW())`,
          [archiveId, pkg.packSeq, pkg.weight || 0, pkg.volume || 0]
        );

        const packageId = packageResult.insertId;

        // 插入板件ID信息
        if (pkg.partIDs && Array.isArray(pkg.partIDs)) {
          for (const partId of pkg.partIDs) {
            await connection.query(
              `INSERT INTO part_archive (package_id, part_id, part_name, part_quantity, created_at) 
              VALUES (?, ?, ?, ?, NOW())`,
              [packageId, partId, pkg.partNames ? pkg.partNames[partId] : '', 1]
            );
          }
        }
      }

      await connection.commit();
      return archiveId;
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  /**
   * 获取归档列表
   * @param {number} page - 页码
   * @param {number} pageSize - 每页数量
   * @returns {Promise} 归档列表
   */
  static async getArchiveList(page = 1, pageSize = 20) {
    const db = Database.getInstance();
    const offset = (page - 1) * pageSize;

    try {
      // 查询归档列表
      const [archives] = await db.query(
        `SELECT * FROM customer_archive 
        ORDER BY archive_date DESC 
        LIMIT ? OFFSET ?`,
        [pageSize, offset]
      );

      // 查询总数
      const [countResult] = await db.query(
        `SELECT COUNT(*) as total FROM customer_archive`
      );

      return {
        success: true,
        data: archives,
        total: countResult[0].total,
        page,
        pageSize,
      };
    } catch (error) {
      console.error('获取归档列表失败:', error);
      return {
        success: false,
        message: `获取归档列表失败: ${error.message}`,
      };
    }
  }

  /**
   * 获取归档详情
   * @param {number} archiveId - 归档ID
   * @returns {Promise} 归档详情
   */
  static async getArchiveDetail(archiveId) {
    const db = Database.getInstance();

    try {
      // 查询归档信息
      const [archives] = await db.query(
        `SELECT * FROM customer_archive WHERE id = ?`,
        [archiveId]
      );

      if (!archives || archives.length === 0) {
        return {
          success: false,
          message: '归档记录不存在',
        };
      }

      const archive = archives[0];

      // 查询包信息
      const [packages] = await db.query(
        `SELECT * FROM package_archive WHERE archive_id = ?`,
        [archiveId]
      );

      // 为每个包查询板件信息
      for (const pkg of packages) {
        const [parts] = await db.query(
          `SELECT * FROM part_archive WHERE package_id = ?`,
          [pkg.id]
        );
        pkg.parts = parts;
      }

      return {
        success: true,
        data: {
          ...archive,
          packages,
        },
      };
    } catch (error) {
      console.error('获取归档详情失败:', error);
      return {
        success: false,
        message: `获取归档详情失败: ${error.message}`,
      };
    }
  }

  /**
   * 恢复归档
   * @param {number} archiveId - 归档ID
   * @param {string} operator - 操作员
   * @returns {Promise} 恢复结果
   */
  static async restoreArchive(archiveId, operator = 'system') {
    const db = Database.getInstance();

    try {
      // 获取归档信息
      const archiveResult = await this.getArchiveDetail(archiveId);
      if (!archiveResult.success) {
        return archiveResult;
      }

      const archive = archiveResult.data;

      // 创建输出目录
      const outputDir = path.join(config.outputPath, archive.customer_name);
      await fs.mkdir(outputDir, { recursive: true });

      // 解压备份文件
      const backupPath = archive.backup_path;
      if (!fs.existsSync(backupPath)) {
        throw new Error('备份文件不存在');
      }

      await this.extractArchive(backupPath, outputDir);

      // 恢复客户状态
      await DataManager.updateCustomerStatus(
        archive.customer_name,
        '已打包',
        `从归档恢复，原归档ID: ${archiveId}`,
        operator
      );

      return {
        success: true,
        message: `客户 ${archive.customer_name} 已成功恢复`,
      };
    } catch (error) {
      console.error('恢复归档失败:', error);
      return {
        success: false,
        message: `恢复归档失败: ${error.message}`,
      };
    }
  }

  /**
   * 解压归档文件
   * @param {string} archivePath - 归档文件路径
   * @param {string} outputPath - 输出目录
   */
  static async extractArchive(archivePath, outputPath) {
    const yauzl = require('yauzl');
    const fs = require('fs');
    const path = require('path');

    return new Promise((resolve, reject) => {
      yauzl.open(archivePath, { lazyEntries: true }, (err, zipfile) => {
        if (err) return reject(err);

        zipfile.readEntry();

        zipfile.on('entry', entry => {
          if (/\/$/.test(entry.fileName)) {
            // 目录
            fs.mkdir(
              path.join(outputPath, entry.fileName),
              { recursive: true },
              err => {
                if (err) return reject(err);
                zipfile.readEntry();
              }
            );
          } else {
            // 文件
            zipfile.openReadStream(entry, (err, readStream) => {
              if (err) return reject(err);

              const destPath = path.join(outputPath, entry.fileName);
              const dir = path.dirname(destPath);

              fs.mkdir(dir, { recursive: true }, err => {
                if (err) return reject(err);

                const writeStream = fs.createWriteStream(destPath);
                readStream.pipe(writeStream);

                writeStream.on('close', () => {
                  zipfile.readEntry();
                });
              });
            });
          }
        });

        zipfile.on('end', () => {
          resolve();
        });

        zipfile.on('error', err => {
          reject(err);
        });
      });
    });
  }
}

module.exports = CustomerArchiveManager;
```

### 5.2 归档 API 实现

在 `electron-main.js` 中添加以下 IPC 处理程序：

```javascript
// 客户归档相关处理程序
ipcMain.handle(
  'archive-customer',
  async (event, customerName, operator = 'system', remark = '') => {
    try {
      const CustomerArchiveManager = require('../utils/customer-archive-manager');
      const result = await CustomerArchiveManager.archiveCustomer(
        customerName,
        operator,
        remark
      );

      if (result.success) {
        // 归档成功后刷新客户列表
        if (mainWindow) {
          mainWindow.webContents.send('archive-success', {
            customerName,
            archiveId: result.archiveId,
          });
        }
      }

      return result;
    } catch (error) {
      console.error('归档客户失败:', error);
      return { success: false, message: `归档客户失败: ${error.message}` };
    }
  }
);

// 获取归档列表
ipcMain.handle('get-archive-list', async (event, page = 1, pageSize = 20) => {
  try {
    const CustomerArchiveManager = require('../utils/customer-archive-manager');
    return await CustomerArchiveManager.getArchiveList(page, pageSize);
  } catch (error) {
    console.error('获取归档列表失败:', error);
    return { success: false, message: `获取归档列表失败: ${error.message}` };
  }
});

// 获取归档详情
ipcMain.handle('get-archive-detail', async (event, archiveId) => {
  try {
    const CustomerArchiveManager = require('../utils/customer-archive-manager');
    return await CustomerArchiveManager.getArchiveDetail(archiveId);
  } catch (error) {
    console.error('获取归档详情失败:', error);
    return { success: false, message: `获取归档详情失败: ${error.message}` };
  }
});

// 恢复归档
ipcMain.handle(
  'restore-archive',
  async (event, archiveId, operator = 'system') => {
    try {
      const CustomerArchiveManager = require('../utils/customer-archive-manager');
      const result = await CustomerArchiveManager.restoreArchive(
        archiveId,
        operator
      );

      if (result.success) {
        // 恢复成功后刷新客户列表
        if (mainWindow) {
          mainWindow.webContents.send('restore-success', {
            customerName: result.customerName,
            archiveId,
          });
        }
      }

      return result;
    } catch (error) {
      console.error('恢复归档失败:', error);
      return { success: false, message: `恢复归档失败: ${error.message}` };
    }
  }
);
```

### 5.3 前端实现

#### 5.3.1 添加归档历史菜单项

在左侧导航菜单中添加"归档历史"选项：

```javascript
// 在左侧菜单中添加
<li class="nav-item" id="archive-history-nav">
  <a href="#" class="nav-link">
    <i class="fas fa-archive"></i>
    <span>归档历史</span>
  </a>
</li>
```

#### 5.3.2 实现归档列表页面

创建归档列表页面组件：

```javascript
// 创建归档列表页面
function showArchiveHistory(page = 1, pageSize = 20) {
  // 创建模态框
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.display = 'block';

  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <h2>归档历史</h2>
        <span class="close">&times;</span>
      </div>
      <div class="modal-body">
        <!-- 搜索区域 -->
        <div class="search-area">
          <div class="search-row">
            <label>客户名称:</label>
            <input type="text" id="archive-customer-name" class="search-input">
          </div>
          <div class="search-row">
            <label>归档日期:</label>
            <input type="date" id="archive-start-date" class="search-input">
            <span>至</span>
            <input type="date" id="archive-end-date" class="search-input">
          </div>
          <div class="search-row">
            <label>操作员:</label>
            <select id="archive-operator" class="search-select">
              <option value="">全部</option>
              <option value="admin">admin</option>
              <option value="user1">user1</option>
              <option value="user2">user2</option>
            </select>
          </div>
          <div class="search-row">
            <button id="search-archive-btn" class="btn btn-primary">搜索</button>
          </div>
        </div>

        <!-- 数据表格 -->
        <div class="table-container">
          <table class="data-table">
            <thead>
              <tr>
                <th>客户名称</th>
                <th>归档日期</th>
                <th>包数量</th>
                <th>板件总数</th>
                <th>操作员</th>
                <th>操作</th>
              </tr>
            </thead>
            <tbody id="archive-list-tbody">
              <!-- 数据将通过JavaScript动态加载 -->
            </tbody>
          </table>
        </div>

        <!-- 分页控件 -->
        <div class="pagination-container">
          <div class="pagination-info">
            显示第 <span id="page-start">1</span> 至 <span id="page-end">20</span> 条，共 <span id="total-records">0</span> 条记录
          </div>
          <div class="pagination-controls">
            <button id="prev-page-btn" class="btn btn-secondary">上一页</button>
            <div class="page-numbers" id="page-numbers">
              <!-- 页码将通过JavaScript动态生成 -->
            </div>
            <button id="next-page-btn" class="btn btn-secondary">下一页</button>
          </div>
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // 关闭按钮事件
  modal.querySelector('.close').addEventListener('click', () => {
    modal.remove();
  });

  // 点击模态框外部关闭
  window.addEventListener('click', event => {
    if (event.target === modal) {
      modal.remove();
    }
  });

  // 加载归档列表数据
  loadArchiveList(page, pageSize);

  // 搜索按钮事件
  document
    .getElementById('search-archive-btn')
    .addEventListener('click', () => {
      const customerName = document.getElementById(
        'archive-customer-name'
      ).value;
      const startDate = document.getElementById('archive-start-date').value;
      const endDate = document.getElementById('archive-end-date').value;
      const operator = document.getElementById('archive-operator').value;

      // 执行搜索
      searchArchives(customerName, startDate, endDate, operator, 1, pageSize);
    });

  // 分页按钮事件
  document.getElementById('prev-page-btn').addEventListener('click', () => {
    if (page > 1) {
      loadArchiveList(page - 1, pageSize);
    }
  });

  document.getElementById('next-page-btn').addEventListener('click', () => {
    loadArchiveList(page + 1, pageSize);
  });
}

// 加载归档列表数据
async function loadArchiveList(page = 1, pageSize = 20) {
  try {
    const response = await window.electronAPI.getArchiveList(page, pageSize);
    if (response.success) {
      const {
        data: archives,
        total,
        currentPage,
        pageSize: currentPageSize,
      } = response;

      // 更新表格数据
      const tbody = document.getElementById('archive-list-tbody');
      tbody.innerHTML = '';

      if (archives.length === 0) {
        tbody.innerHTML =
          '<tr><td colspan="6" class="no-data">暂无归档数据</td></tr>';
      } else {
        archives.forEach(archive => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${archive.customer_name}</td>
            <td>${formatDate(archive.archive_date)}</td>
            <td>${archive.packages_count || 0}</td>
            <td>${archive.total_parts_count || 0}</td>
            <td>${archive.archive_user}</td>
            <td>
              <button class="btn btn-info view-archive-btn" data-id="${
                archive.id
              }">查看详情</button>
              <button class="btn btn-warning restore-archive-btn" data-id="${
                archive.id
              }">恢复</button>
            </td>
          `;
          tbody.appendChild(row);
        });

        // 添加查看详情按钮事件
        document.querySelectorAll('.view-archive-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const archiveId = btn.getAttribute('data-id');
            showArchiveDetail(archiveId);
          });
        });

        // 添加恢复按钮事件
        document.querySelectorAll('.restore-archive-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const archiveId = btn.getAttribute('data-id');
            confirmRestoreArchive(archiveId);
          });
        });
      }

      // 更新分页控件
      updatePagination(total, currentPage, currentPageSize);
    } else {
      alert(response.message);
    }
  } catch (error) {
    alert(`加载归档列表失败: ${error.message}`);
  }
}

// 搜索归档
async function searchArchives(
  customerName,
  startDate,
  endDate,
  operator,
  page,
  pageSize
) {
  try {
    // 这里需要实现后端搜索API
    // const response = await window.electronAPI.searchArchives(customerName, startDate, endDate, operator, page, pageSize);
    // 暂时使用模拟数据
    const response = {
      success: true,
      data: [],
      total: 0,
      currentPage: page,
      pageSize: pageSize,
    };

    if (response.success) {
      const {
        data: archives,
        total,
        currentPage,
        pageSize: currentPageSize,
      } = response;

      // 更新表格数据
      const tbody = document.getElementById('archive-list-tbody');
      tbody.innerHTML = '';

      if (archives.length === 0) {
        tbody.innerHTML =
          '<tr><td colspan="6" class="no-data">暂无归档数据</td></tr>';
      } else {
        archives.forEach(archive => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${archive.customer_name}</td>
            <td>${formatDate(archive.archive_date)}</td>
            <td>${archive.packages_count || 0}</td>
            <td>${archive.total_parts_count || 0}</td>
            <td>${archive.archive_user}</td>
            <td>
              <button class="btn btn-info view-archive-btn" data-id="${
                archive.id
              }">查看详情</button>
              <button class="btn btn-warning restore-archive-btn" data-id="${
                archive.id
              }">恢复</button>
            </td>
          `;
          tbody.appendChild(row);
        });

        // 添加查看详情按钮事件
        document.querySelectorAll('.view-archive-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const archiveId = btn.getAttribute('data-id');
            showArchiveDetail(archiveId);
          });
        });

        // 添加恢复按钮事件
        document.querySelectorAll('.restore-archive-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const archiveId = btn.getAttribute('data-id');
            confirmRestoreArchive(archiveId);
          });
        });
      }

      // 更新分页控件
      updatePagination(total, currentPage, currentPageSize);
    } else {
      alert(response.message);
    }
  } catch (error) {
    alert(`搜索归档失败: ${error.message}`);
  }
}

// 更新分页控件
function updatePagination(total, currentPage, pageSize) {
  const totalPages = Math.ceil(total / pageSize);
  const startRecord = (currentPage - 1) * pageSize + 1;
  const endRecord = Math.min(currentPage * pageSize, total);

  document.getElementById('page-start').textContent = startRecord;
  document.getElementById('page-end').textContent = endRecord;
  document.getElementById('total-records').textContent = total;

  // 更新页码按钮
  const pageNumbers = document.getElementById('page-numbers');
  pageNumbers.innerHTML = '';

  // 计算显示的页码范围
  let startPage = Math.max(1, currentPage - 2);
  let endPage = Math.min(totalPages, startPage + 4);

  if (endPage - startPage < 4) {
    startPage = Math.max(1, endPage - 4);
  }

  for (let i = startPage; i <= endPage; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.className = `btn ${
      i === currentPage ? 'btn-primary' : 'btn-secondary'
    }`;
    pageBtn.textContent = i;
    pageBtn.addEventListener('click', () => {
      loadArchiveList(i, pageSize);
    });
    pageNumbers.appendChild(pageBtn);
  }

  // 更新上一页/下一页按钮状态
  document.getElementById('prev-page-btn').disabled = currentPage === 1;
  document.getElementById('next-page-btn').disabled =
    currentPage === totalPages;
}

// 显示归档详情
async function showArchiveDetail(archiveId) {
  try {
    const response = await window.electronAPI.getArchiveDetail(archiveId);
    if (response.success) {
      const { data: archive } = response;

      // 创建模态框
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';

      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <h2>客户归档详情</h2>
            <span class="close">&times;</span>
          </div>
          <div class="modal-body">
            <!-- 客户基本信息 -->
            <div class="info-section">
              <h3>客户基本信息</h3>
              <div class="info-grid">
                <div class="info-item">
                  <label>客户名称:</label>
                  <span>${archive.customer_name}</span>
                </div>
                <div class="info-item">
                  <label>客户地址:</label>
                  <span>${archive.customer_address || '无'}</span>
                </div>
                <div class="info-item">
                  <label>归档日期:</label>
                  <span>${formatDate(archive.archive_date)}</span>
                </div>
                <div class="info-item">
                  <label>归档操作员:</label>
                  <span>${archive.archive_user}</span>
                </div>
                <div class="info-item">
                  <label>包数量:</label>
                  <span>${archive.packages_count || 0}</span>
                </div>
                <div class="info-item">
                  <label>板件总数:</label>
                  <span>${archive.total_parts_count || 0}</span>
                </div>
                <div class="info-item full-width">
                  <label>备注:</label>
                  <span>${archive.remark || '无'}</span>
                </div>
              </div>
            </div>

            <!-- 包信息列表 -->
            <div class="info-section">
              <h3>包信息列表</h3>
              <div class="table-container">
                <table class="data-table">
                  <thead>
                    <tr>
                      <th>包号</th>
                      <th>重量</th>
                      <th>体积</th>
                      <th>创建时间</th>
                      <th>板件列表</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${archive.packages
                      .map(
                        pkg => `
                      <tr>
                        <td>${pkg.pack_seq}</td>
                        <td>${pkg.package_weight || 0}</td>
                        <td>${pkg.package_volume || 0}</td>
                        <td>${formatDate(pkg.created_at)}</td>
                        <td>${pkg.parts.map(p => p.part_id).join(', ')}</td>
                      </tr>
                    `
                      )
                      .join('')}
                  </tbody>
                </table>
              </div>
            </div>

            <!-- 操作按钮 -->
            <div class="action-buttons">
              <button class="btn btn-primary" id="export-excel-btn">导出Excel</button>
              <button class="btn btn-primary" id="export-pdf-btn">导出PDF</button>
              <button class="btn btn-secondary" id="close-detail-btn">关闭</button>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // 关闭按钮事件
      modal.querySelector('.close').addEventListener('click', () => {
        modal.remove();
      });

      document
        .getElementById('close-detail-btn')
        .addEventListener('click', () => {
          modal.remove();
        });

      // 导出Excel按钮事件
      document
        .getElementById('export-excel-btn')
        .addEventListener('click', () => {
          exportArchiveToExcel(archive);
        });

      // 导出PDF按钮事件
      document
        .getElementById('export-pdf-btn')
        .addEventListener('click', () => {
          exportArchiveToPDF(archive);
        });
    } else {
      alert(response.message);
    }
  } catch (error) {
    alert(`获取归档详情失败: ${error.message}`);
  }
}

// 确认恢复归档
function confirmRestoreArchive(archiveId) {
  // 创建确认对话框
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.display = 'block';

  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <h2>确认恢复归档</h2>
        <span class="close">&times;</span>
      </div>
      <div class="modal-body">
        <p>您确定要恢复该归档数据吗？</p>
        <p>恢复后，系统将：</p>
        <ul>
          <li>将备份文件解压到输出目录</li>
          <li>从数据库恢复客户状态</li>
          <li>刷新客户列表</li>
        </ul>
        <div class="modal-buttons">
          <button id="confirm-restore-btn" class="btn btn-primary">确认恢复</button>
          <button id="cancel-restore-btn" class="btn btn-secondary">取消</button>
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // 关闭按钮事件
  modal.querySelector('.close').addEventListener('click', () => {
    modal.remove();
  });

  // 取消按钮事件
  document
    .getElementById('cancel-restore-btn')
    .addEventListener('click', () => {
      modal.remove();
    });

  // 确认按钮事件
  document
    .getElementById('confirm-restore-btn')
    .addEventListener('click', async () => {
      modal.remove();

      try {
        const response = await window.electronAPI.restoreArchive(archiveId);
        if (response.success) {
          alert(response.message);
          // 刷新归档列表
          loadArchiveList();
        } else {
          alert(response.message);
        }
      } catch (error) {
        alert(`恢复归档失败: ${error.message}`);
      }
    });
}

// 导出归档数据到Excel
function exportArchiveToExcel(archive) {
  // 这里需要实现导出Excel的逻辑
  alert('导出Excel功能待实现');
}

// 导出归档数据到PDF
function exportArchiveToPDF(archive) {
  // 这里需要实现导出PDF的逻辑
  alert('导出PDF功能待实现');
}

// 格式化日期
function formatDate(dateString) {
  if (!dateString) return '';

  const date = new Date(dateString);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');

  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}
```

#### 5.3.3 添加归档历史菜单项事件

在初始化事件时添加：

```javascript
// 归档历史菜单项点击事件
document.getElementById('archive-history-nav').addEventListener('click', e => {
  e.preventDefault();
  showArchiveHistory();
});
```

## 6. 注意事项

1. **备份目录创建**：确保 `D:ackup_dataackup\customer` 目录存在且有写入权限。

2. **数据库事务**：归档操作涉及多个数据库表，应使用事务确保数据一致性。

3. **错误处理**：归档过程中可能出现各种错误，应进行适当的错误处理和用户提示。

4. **性能考虑**：对于大量数据的归档，可能需要考虑分批处理和进度提示。

5. **权限控制**：确保只有授权用户才能执行归档和恢复操作。

## 7. 测试计划

1. **归档功能测试**：

   - 归档正常客户数据
   - 归档无包数据的客户
   - 归档过程中断测试（如磁盘空间不足）
   - 归档后验证数据完整性

2. **归档历史查看测试**：

   - 查看归档列表
   - 搜索和筛选功能测试
   - 查看归档详情
   - 导出功能测试

3. **恢复功能测试**：

   - 恢复归档数据
   - 恢复后验证数据完整性
   - 恢复过程中断测试

4. **边界条件测试**：
   - 空归档列表
   - 无效归档 ID
   - 无效客户名称
   - 大量数据归档和恢复

## 8. 总结

通过以上设计，我们实现了完整的客户归档功能，包括归档、查看和恢复功能。归档后的数据可以通过"归档历史"功能进行查看，必要时还可以恢复。这种设计既满足了数据审计和追溯的需求，又提供了数据恢复的可能性，同时保持了系统的整洁性（删除本地已归档的客户文件夹）。
