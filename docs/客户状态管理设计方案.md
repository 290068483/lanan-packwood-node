# 客户状态管理设计方案

## 一、状态设计

### 1. 状态定义
基于packages.json中的partIDs数据，设计以下客户状态：
1. **未打包**：客户数据已导入，但在packages.json中没有对应的partIDs记录
2. **正在处理**：客户数据正在打包过程中，部分partIDs可能已记录在packages.json中
3. **已打包**：客户所有数据都已在packages.json中找到对应的partIDs记录
4. **已归档**：已打包的客户数据已归档保存
5. **已出货**：已归档的客户货物已出货
6. **未出货**：已归档的客户货物尚未出货

### 2. 状态判断逻辑
- **未打包**：客户数据在packages.json中找不到对应的partIDs记录
- **正在处理**：部分partIDs已在packages.json中找到，但不是全部
- **已打包**：客户所有partIDs都在packages.json中找到对应记录
- **已归档/已出货/未出货**：基于业务流程手动设置的状态

## 二、数据结构设计

### 1. 客户数据结构
```javascript
{
  // ... 原有字段 ...
  status: '未打包', // 客户状态
  statusHistory: [ // 状态变更历史
    {
      status: '未打包',
      timestamp: '2023-01-01 10:00:00',
      operator: '系统',
      remark: '初始状态'
    }
  ],
  lastStatusUpdate: '2023-01-01 10:00:00', // 最后状态更新时间
  packDate: '2023-01-01 10:00:00', // 打包时间
  archiveDate: '2023-01-02 10:00:00', // 归档时间
  shipmentDate: '2023-01-03 10:00:00', // 出货时间
  totalParts: 100, // 客户总板件数
  packedParts: 0, // 已打包板件数
  packSeqs: [], // 客户的所有包号
  lastPackCheck: '2023-01-01 10:00:00' // 最后检查打包状态的时间
}
```

### 2. packages.json结构
```json
[
  {
    "packSeq": "1",
    "packNo": "1110953111252",
    "packDate": "2023-01-01 10:52:30",
    "partIDs": [
      "58b2e383702249219bc6744e0419a9e6",
      "02e74f241107448d84947c22e43db18d"
    ]
  },
  {
    "packSeq": "2",
    "packNo": "1110953111253",
    "packDate": "2023-01-01 11:00:00",
    "partIDs": [
      "92b0350c40034acea092f1f99dcd1ea4",
      "d3ad19afc3d14a8b950021003c89b68c"
    ]
  }
]
```

## 三、状态判断算法

### 1. 打包状态检查算法
```javascript
function checkPackStatus(customerData, packagesData) {
  // 1. 获取客户所有板件的ID
  const allPartIDs = customerData.panels.map(panel => panel.id);

  // 2. 从packages.json中提取所有partIDs
  const allPackedPartIDs = [];
  if (packagesData && Array.isArray(packagesData)) {
    packagesData.forEach(packageItem => {
      if (packageItem.partIDs && Array.isArray(packageItem.partIDs)) {
        allPackedPartIDs.push(...packageItem.partIDs);
      }
    });
  }

  // 3. 计算已打包的板件数
  let packedCount = 0;
  allPartIDs.forEach(partID => {
    if (allPackedPartIDs.includes(partID)) {
      packedCount++;
    }
  });

  // 4. 计算打包进度
  const packProgress = Math.round((packedCount / allPartIDs.length) * 100);

  // 5. 确定客户状态
  let status = '未打包';
  if (packProgress === 100) {
    status = '已打包';
  } else if (packProgress > 0) {
    status = '正在处理';
  }

  // 6. 获取客户的所有包号
  const customerPackSeqs = [];
  if (packagesData && Array.isArray(packagesData)) {
    packagesData.forEach(packageItem => {
      if (packageItem.partIDs && Array.isArray(packageItem.partIDs)) {
        // 检查这个包是否包含客户的板件
        const hasCustomerParts = packageItem.partIDs.some(partID => allPartIDs.includes(partID));
        if (hasCustomerParts) {
          customerPackSeqs.push(packageItem.packSeq);
        }
      }
    });
  }

  return {
    status,
    packedCount,
    totalParts: allPartIDs.length,
    packProgress,
    packSeqs: customerPackSeqs
  };
}
```

## 四、界面设计

### 1. 客户表格
- 添加"状态"列，显示客户当前状态
- 添加"打包进度"列，显示已打包板件数/总板件数
- 添加"包号"列，显示客户的所有包号

### 2. 状态颜色标识
- 未打包：灰色
- 正在处理：蓝色
- 已打包：黄色
- 已归档：紫色
- 已出货：绿色
- 未出货：橙色

### 3. 操作按钮
- 根据客户状态显示不同的操作按钮
- "已打包"状态后，显示"归档"按钮
- "已归档"状态后，显示"出货"和"标记为未出货"按钮

## 五、功能实现

### 1. 打包状态监控
- 定期检查packages.json文件的变化
- 当packages.json更新时，重新计算客户状态
- 如果状态发生变化，更新客户数据并记录状态变更历史

### 2. 状态变更API
- `POST /api/customers/:id/check-status` - 检查客户打包状态
- `POST /api/customers/:id/archive` - 归档客户
- `POST /api/customers/:id/ship` - 出货
- `POST /api/customers/:id/mark-not-shipped` - 标记为未出货

### 3. 自动状态更新
- 监听packages.json文件变化
- 当检测到变化时，自动更新相关客户的状态
- 记录状态变更历史

## 六、数据持久化

### 1. 客户数据更新
- 当检测到packages.json变化时，更新客户数据
- 更新已打包板件数和打包进度
- 更新客户包号列表

### 2. 状态变更记录
- 每次状态变更都记录到状态历史中
- 包含状态、时间、操作人员和备注信息

## 七、业务规则

### 1. 打包状态判断规则
- 当客户所有板件都找到对应的partIDs时，状态自动更新为"已打包"
- 当部分板件找到对应的partIDs时，状态为"正在处理"
- 当没有板件找到对应的partIDs时，状态为"未打包"

### 2. 归档规则
- 只有"已打包"状态的客户才能进行归档
- 归档后状态更新为"已归档"

### 3. 出货规则
- 只有"已归档"状态的客户才能进行出货
- 出货后状态更新为"已出货"
- 可以将"已归档"状态的客户标记为"未出货"

## 八、用户体验优化

### 1. 打包进度可视化
- 使用进度条显示客户打包进度
- 显示已打包板件数和总板件数

### 2. 状态变更通知
- 状态变更时显示通知
- 显示状态变更原因和时间

### 3. 包号详情
- 点击包号可以查看包的详细信息
- 显示包中的板件列表和打包时间

## 九、第一阶段实施建议

### 1. 实施步骤
1. **数据结构扩展**
   - 在客户数据对象中添加状态相关字段
   - 创建状态枚举定义

2. **状态判断算法实现**
   - 实现checkPackStatus函数
   - 集成到现有数据处理流程中

3. **界面更新**
   - 添加状态列和进度列
   - 实现状态颜色标识
   - 根据状态显示操作按钮

4. **状态变更API实现**
   - 实现检查状态API
   - 实现归档和出货API

5. **文件监控集成**
   - 集成packages.json文件监控
   - 实现自动状态更新

### 2. 实施优先级
1. **高优先级**：数据结构扩展、状态判断算法实现、界面更新
2. **中优先级**：状态变更API实现、文件监控集成
3. **低优先级**：用户体验优化（进度条、通知等）

### 3. 实施时间预估
- 数据结构扩展：1-2天
- 状态判断算法实现：1天
- 界面更新：2-3天
- 状态变更API实现：2天
- 文件监控集成：1-2天
- 测试与调整：2天

总计：约9-12天

### 4. 风险评估
- **主要风险**：packages.json格式可能存在变化
- **应对措施**：实现健壮的数据解析逻辑，处理各种可能的格式变化
- **备选方案**：如果packages.json格式变化太大，可以引入配置文件定义解析规则

### 5. 测试计划
1. **单元测试**：测试状态判断算法
2. **集成测试**：测试文件监控和状态更新流程
3. **UI测试**：测试界面显示和操作按钮
4. **端到端测试**：测试完整的状态变更流程

## 十、后续阶段规划

### 1. 第二阶段：高级功能
1. **时间因素集成**
   - 在diff算法中加入时间因素
   - 实现更精确的变化检测
   - 记录打包进度历史

2. **增强的状态监控**
   - 实现增量状态更新
   - 优化文件监控性能
   - 添加变化详情分析

### 2. 第三阶段：用户体验优化
1. **高级可视化**
   - 实现打包进度历史图表
   - 添加状态变更时间线
   - 实现包号详情弹窗

2. **批量操作**
   - 支持批量状态变更
   - 实现批量状态筛选
   - 添加批量操作确认机制

### 3. 第四阶段：高级功能
1. **智能状态预测**
   - 基于历史数据预测打包完成时间
   - 实现状态变更预警
   - 添加异常状态检测

2. **高级报表**
   - 实现打包状态报表
   - 添加状态变更统计
   - 实现自定义报表生成

## 十一、参考实现

### 1. old系统中的打包算法
old系统中的打包状态判断主要基于以下逻辑：
- 通过遍历packages.json文件中的partIDs数组
- 将partIDs与客户板件明细中的ID进行匹配
- 如果所有板件ID都能在packages.json中找到对应记录，则认为客户已打包完成

### 2. old系统中的打包记录生成
old系统中的打包记录生成过程：
1. 读取packages.json文件，获取所有包信息
2. 遍历每个包中的partIDs
3. 根据partIDs在原始板件明细中查找对应记录
4. 将匹配的板件信息记录到"已包板件"表格中
5. 标记未找到的板件（显示为"<没有此板排版记录>"）

### 3. old系统中的打包状态检查
在old系统中，通过"遍历列表记录文件各和json时间"函数实现：
- 检查local文件夹中各子文件夹的json文件时间
- 根据json文件的保存时间刷新打包记录
- 比较json文件时间与列表记录时间，判断是否有更新

## 十二、总结

本设计方案提供了完整的客户状态管理解决方案，包括状态定义、数据结构、界面设计、功能实现、数据持久化、业务规则和用户体验优化等方面。第一阶段实施重点在于基础功能的实现，确保系统能够准确判断和更新客户状态。后续阶段将在此基础上添加高级功能和优化用户体验。
